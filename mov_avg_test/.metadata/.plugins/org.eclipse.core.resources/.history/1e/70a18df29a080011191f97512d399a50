  /******************************************************************************
  * @file           : main.c
  * @brief          : Main program body
  * (c) CG2028 Teaching Team
  ******************************************************************************/


/*--------------------------- Includes ---------------------------------------*/
#include "main.h"
#include "../../Drivers/BSP/B-L4S5I-IOT01/stm32l4s5i_iot01_accelero.h"
#include "../../Drivers/BSP/B-L4S5I-IOT01/stm32l4s5i_iot01_tsensor.h"
#include "../../Drivers/BSP/B-L4S5I-IOT01/stm32l4s5i_iot01_gyro.h"

#include "stdio.h"
#include "string.h"
#include <sys/stat.h>
#include <math.h>  // For sqrtf function

// Add buzzer pin definition
#define BUZZER_PIN GPIO_PIN_13
#define BUZZER_PORT GPIOC

// Fall detection definitions
#define FREEFALL_THRESHOLD 9.0f      // m/s² - just slightly below normal gravity
#define IMPACT_THRESHOLD 11.0f       // m/s² - very light slam
#define GYRO_THRESHOLD 1000.0f       // deg/s - high to avoid false triggers from your high baseline
#define LYING_THRESHOLD 11.0f        // m/s²
#define FALL_DETECTION_TIME 2000     // ms
#define LYING_DETECTION_TIME 3000    // ms

// Fall detection states
typedef enum {
    STATE_NORMAL = 0,
    STATE_FREEFALL_DETECTED = 1,
    STATE_IMPACT_DETECTED = 2,
    STATE_FALL_CONFIRMED = 3
} FallState;

// Fall detection global variables
FallState fall_state = STATE_NORMAL;
uint32_t freefall_timestamp = 0;
uint32_t impact_timestamp = 0;
uint32_t lying_timestamp = 0;


static void UART1_Init(void);

extern void initialise_monitor_handles(void);	// for semi-hosting support (printf). Will not be required if transmitting via UART

extern int mov_avg(int N, int* accel_buff); // asm implementation

int mov_avg_C(int N, int* accel_buff); // Reference C implementation

UART_HandleTypeDef huart1;

// Function to initialize buzzer
void Buzzer_Init(void)
{
    __HAL_RCC_GPIOC_CLK_ENABLE();

    GPIO_InitTypeDef GPIO_InitStruct = {0};
    GPIO_InitStruct.Pin = BUZZER_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(BUZZER_PORT, &GPIO_InitStruct);

    // Turn off buzzer initially
    HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);
}

// Function to turn buzzer on
void Buzzer_On(void)
{
    HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_SET);
}

// Function to turn buzzer off
void Buzzer_Off(void)
{
    HAL_GPIO_WritePin(BUZZER_PORT, BUZZER_PIN, GPIO_PIN_RESET);
}

// Function to toggle buzzer
void Buzzer_Toggle(void)
{
    HAL_GPIO_TogglePin(BUZZER_PORT, BUZZER_PIN);
}


int main(void)
{
	const int N=4;

	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();

	/* UART initialization  */
	UART1_Init();

	/* Peripheral initializations using BSP functions */
	BSP_LED_Init(LED2);
	BSP_ACCELERO_Init();
	BSP_GYRO_Init();

    /* Initialize buzzer */
    Buzzer_Init();

	/*Set the initial LED state to off*/
	BSP_LED_Off(LED2);
    Buzzer_Off();

	int accel_buff_x[4]={0};
	int accel_buff_y[4]={0};
	int accel_buff_z[4]={0};
	int i=0;
	int delay_ms=50; //change delay time to suit your code

	while (1)
	{

		BSP_LED_Toggle(LED2);		// This function helps to toggle the current LED state

		int16_t accel_data_i16[3] = { 0 };			// array to store the x, y and z readings of accelerometer
		/********Function call to read accelerometer values*********/
		BSP_ACCELERO_AccGetXYZ(accel_data_i16);

		//Copy the values over to a circular style buffer
		accel_buff_x[i%4]=accel_data_i16[0]; //acceleration along X-Axis
		accel_buff_y[i%4]=accel_data_i16[1]; //acceleration along Y-Axis
		accel_buff_z[i%4]=accel_data_i16[2]; //acceleration along Z-Axis


		// ********* Read gyroscope values *********/
		float gyro_data[3]={0.0};
		float* ptr_gyro=gyro_data;
		BSP_GYRO_GetXYZ(ptr_gyro);

		//The output of gyro has been made to display in dps(degree per second)
		float gyro_velocity[3]={0.0};
		gyro_velocity[0]=(gyro_data[0]*9.8/(1000));
		gyro_velocity[1]=(gyro_data[1]*9.8/(1000));
		gyro_velocity[2]=(gyro_data[2]*9.8/(1000));


		//Preprocessing the filtered outputs  The same needs to be done for the output from the C program as well
		float accel_filt_asm[3]={0}; // final value of filtered acceleration values

		accel_filt_asm[0]= (float)mov_avg(N,accel_buff_x) * (9.8/1000.0f);
		accel_filt_asm[1]= (float)mov_avg(N,accel_buff_y) * (9.8/1000.0f);
		accel_filt_asm[2]= (float)mov_avg(N,accel_buff_z) * (9.8/1000.0f);


		//Preprocessing the filtered outputs  The same needs to be done for the output from the assembly program as well
		float accel_filt_c[3]={0};

		accel_filt_c[0]=(float)mov_avg_C(N,accel_buff_x) * (9.8/1000.0f);
		accel_filt_c[1]=(float)mov_avg_C(N,accel_buff_y) * (9.8/1000.0f);
		accel_filt_c[2]=(float)mov_avg_C(N,accel_buff_z) * (9.8/1000.0f);

		/***************************UART transmission*******************************************/
		char buffer[150]; // Create a buffer large enough to hold the text

		/******Transmitting results of C execution over UART*********/
		if(i>=3)
		{
			// 1. First printf() Equivalent
			sprintf(buffer, "Results of C execution for filtered accelerometer readings:\r\n");
			HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

			// 2. Second printf() (with Floats) Equivalent
			// Note: Requires -u _printf_float to be enabled in Linker settings
			sprintf(buffer, "Averaged X : %f; Averaged Y : %f; Averaged Z : %f;\r\n",
					accel_filt_c[0], accel_filt_c[1], accel_filt_c[2]);
			HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

			/******Transmitting results of asm execution over UART*********/

			// 1. First printf() Equivalent
			sprintf(buffer, "Results of assembly execution for filtered accelerometer readings:\r\n");
			HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

			// 2. Second printf() (with Floats) Equivalent
			// Note: Requires -u _printf_float to be enabled in Linker settings
			sprintf(buffer, "Averaged X : %f; Averaged Y : %f; Averaged Z : %f;\r\n",
					accel_filt_asm[0], accel_filt_asm[1], accel_filt_asm[2]);
			HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

			/******Transmitting Gyroscope readings over UART*********/

			// 1. First printf() Equivalent
			sprintf(buffer, "Gyroscope sensor readings:\r\n");
			HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

			// 2. Second printf() (with Floats) Equivalent
			// Note: Requires -u _printf_float to be enabled in Linker settings
			sprintf(buffer, "Averaged X : %f; Averaged Y : %f; Averaged Z : %f;\r\n\n",
					gyro_velocity[0], gyro_velocity[1], gyro_velocity[2]);
			HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		}

		HAL_Delay(delay_ms);	// 1 second delay

		i++;


//		Key Features of this Fall Detection Algorithm:
//
//		Multi-stage Detection:
//
//		Stage 1 (Freefall): Detects very low acceleration (< 0.5 m/s²) indicating person is falling
//		Stage 2 (Impact): Detects sudden high acceleration (> 20 m/s²) or rapid rotation
//		Stage 3 (Lying): Confirms person remains still on the ground for 5+ seconds
//
//
//		False Positive Prevention:
//
//		Requires all three stages to occur in sequence
//		Has timeouts to reset if stages don't occur in expected pattern
//		Distinguishes between controlled movements (sitting down) vs. uncontrolled falls
//
//
//		LED Feedback:
//
//		Normal state: Slow blink (1000ms delay)
//		Fall confirmed: Fast blink (200ms delay) - emergency alert
//
//
//		UART Logging:
//
//		Prints diagnostic messages at each stage
//		Clear emergency alert when fall is confirmed
//
//
//		Expandable:
//
//		Ready to add WiFi/Bluetooth alerts
//		Ready to add buzzer
//		Ready to add manual reset button

		// ********* Fall detection *********/
		// write your program from here:

		if(i>=3)
		{
		    float accel_magnitude = sqrtf(accel_filt_asm[0]*accel_filt_asm[0] +
		                                   accel_filt_asm[1]*accel_filt_asm[1] +
		                                   accel_filt_asm[2]*accel_filt_asm[2]);

		    float gyro_magnitude = sqrtf(gyro_velocity[0]*gyro_velocity[0] +
		                                  gyro_velocity[1]*gyro_velocity[1] +
		                                  gyro_velocity[2]*gyro_velocity[2]);

		    sprintf(buffer, "DEBUG: Accel: %.2f m/s², Gyro: %.2f deg/s, State: %d\r\n",
		            accel_magnitude, gyro_magnitude, fall_state);
		    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);

		    uint32_t current_time = HAL_GetTick();

		    // Handle LED and buzzer based on state
		    if(fall_state == STATE_FALL_CONFIRMED)
		    {
		        // EMERGENCY MODE - Rapid LED blinking and buzzer alarm
		        if((current_time - last_led_toggle) > 100)  // Blink every 100ms
		        {
		            BSP_LED_Toggle(LED2);
		            last_led_toggle = current_time;
		        }

		        // Buzzer beeps in pattern: 200ms on, 200ms off
		        if((current_time - last_buzzer_toggle) > 200)
		        {
		            Buzzer_Toggle();
		            last_buzzer_toggle = current_time;
		        }

		        delay_ms = 50;  // Fast loop for rapid response
		    }
		    else if(fall_state == STATE_IMPACT_DETECTED)
		    {
		        // WARNING MODE - Medium speed blinking
		        if((current_time - last_led_toggle) > 250)
		        {
		            BSP_LED_Toggle(LED2);
		            last_led_toggle = current_time;
		        }
		        Buzzer_Off();  // No buzzer yet
		        delay_ms = 100;
		    }
		    else
		    {
		        // NORMAL MODE - Slow blinking (controlled by main loop delay)
		        // LED toggle happens in main loop
		        Buzzer_Off();
		        delay_ms = 1000;
		    }

		    // State machine for fall detection
		    switch(fall_state)
		    {
		        case STATE_NORMAL:
		            // Look for impact (slam on table)
		            if(accel_magnitude > IMPACT_THRESHOLD)
		            {
		                fall_state = STATE_IMPACT_DETECTED;
		                impact_timestamp = current_time;
		                lying_timestamp = 0;

		                sprintf(buffer, "*** IMPACT DETECTED! Magnitude: %.2f m/s² ***\r\n", accel_magnitude);
		                HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		            }
		            break;

		        case STATE_IMPACT_DETECTED:
		            // Look for stillness after impact
		            if(accel_magnitude < LYING_THRESHOLD && gyro_magnitude < GYRO_THRESHOLD)
		            {
		                if(lying_timestamp == 0)
		                {
		                    lying_timestamp = current_time;
		                    sprintf(buffer, "*** Board is still - checking for fall... ***\r\n");
		                    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                }
		                else if((current_time - lying_timestamp) > LYING_DETECTION_TIME)
		                {
		                    fall_state = STATE_FALL_CONFIRMED;

		                    sprintf(buffer, "\r\n!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n");
		                    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                    sprintf(buffer, "!!! FALL CONFIRMED - HELP NEEDED !!!\r\n");
		                    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                    sprintf(buffer, "!!! BUZZER AND LED ALARM ACTIVE  !!!\r\n");
		                    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                    sprintf(buffer, "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\r\n\r\n");
		                    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                }
		            }
		            else
		            {
		                lying_timestamp = 0;
		                if((current_time - impact_timestamp) > 5000)
		                {
		                    fall_state = STATE_NORMAL;
		                    sprintf(buffer, "*** No fall - returning to normal ***\r\n");
		                    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                }
		            }
		            break;

		        case STATE_FALL_CONFIRMED:
		            // Emergency alert - handled above with LED and buzzer
		            // Print alert message every 5 seconds
		            static uint32_t last_alert_time = 0;
		            if((current_time - last_alert_time) > 5000)
		            {
		                sprintf(buffer, "*** EMERGENCY ALERT ACTIVE - BUZZER SOUNDING ***\r\n");
		                HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), HAL_MAX_DELAY);
		                last_alert_time = current_time;
		            }
		            break;
		    }
		}


	}

}



int mov_avg_C(int N, int* accel_buff)
{ 	// The implementation below is inefficient and meant only for verifying your results.
	int result=0;
	for(int i=0; i<N;i++)
	{
		result+=accel_buff[i];
	}

	result=result/4;

	return result;
}

static void UART1_Init(void)
{
        /* Pin configuration for UART. BSP_COM_Init() can do this automatically */
        __HAL_RCC_GPIOB_CLK_ENABLE();
         __HAL_RCC_USART1_CLK_ENABLE();

        GPIO_InitTypeDef GPIO_InitStruct = {0};
        GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
        GPIO_InitStruct.Pin = GPIO_PIN_7|GPIO_PIN_6;
        GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
        GPIO_InitStruct.Pull = GPIO_NOPULL;
        GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
        HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);

        /* Configuring UART1 */
        huart1.Instance = USART1;
        huart1.Init.BaudRate = 115200;
        huart1.Init.WordLength = UART_WORDLENGTH_8B;
        huart1.Init.StopBits = UART_STOPBITS_1;
        huart1.Init.Parity = UART_PARITY_NONE;
        huart1.Init.Mode = UART_MODE_TX_RX;
        huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
        huart1.Init.OverSampling = UART_OVERSAMPLING_16;
        huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
        huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
        if (HAL_UART_Init(&huart1) != HAL_OK)
        {
          while(1);
        }

}


// Do not modify these lines of code. They are written to supress UART related warnings
int _read(int file, char *ptr, int len) { return 0; }
int _fstat(int file, struct stat *st) { return 0; }
int _lseek(int file, int ptr, int dir) { return 0; }
int _isatty(int file) { return 1; }
int _close(int file) { return -1; }
int _getpid(void) { return 1; }
int _kill(int pid, int sig) { return -1; }
